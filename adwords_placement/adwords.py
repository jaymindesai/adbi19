import sys
import math
import random
from collections import defaultdict

import pandas as pd


def prep_data():
    """
    Prepares the data used to calculate revenue.

    :returns:
        advertisers : dict[key: 'query', value: set{('advertiser', 'bid')}])
            Adjacency list representation of query-advertiser bi-partite graph. Since we only care about the advertisers
            with respect to query terms/ad-words in this project, the graph constructed is a directed graph with all the
            edges from 'query' to 'advertisers'.
        budget : dict[key: 'advertiser', value: 'budget']
            Dictionary representing the daily budget of advertisers.
        queries : list
            List of incoming query terms/ad-words.
    """
    budget = dict()
    advertisers = defaultdict(set)
    for _, rows in pd.read_csv('bidder_dataset.csv').iterrows():
        advertisers[rows['Keyword']].add((rows['Advertiser'], rows['Bid Value']))
        if not math.isnan(rows['Budget']):
            budget[rows['Advertiser']] = rows['Budget']
    with open('queries.txt', 'r') as f:
        queries = f.read().splitlines()
    return budget, advertisers, queries


def calculate_revenue(strategy, initial_budget, current_budget, advertisers, queries):
    """
    Calculates the revenue over one pass of all the query terms/ad-words using one of the the given strategies
    from {'greedy, 'balance', 'msvv'}.

    :returns:
        revenue : int
            revenue generated by the algorithm.
    """
    # Get the algorithm to be used for ad-words allocation using given strategy.
    algorithm = get_algorithm(strategy, initial_budget, current_budget)
    revenue = 0
    for query in queries:
        # sort the advertisers for this query term/ad-word using algorithm as the key.
        for nbr, bid in sorted(advertisers[query], key=algorithm):
            try:
                # If all bidding advertiser have exhausted their full budget, continue.
                if current_budget[nbr] >= bid:
                    revenue += bid
                    current_budget[nbr] -= bid
                    # adhering to the assumption that each advertisement slot can be allocated to only one advertiser.
                    raise StopIteration
            except StopIteration:
                # Since this query term/ad-word has already ben allocated a slot, move on to the next ad-word.
                break
    return revenue


def get_algorithm(strategy, initial_budget, current_budget):
    """
    This function implements the core logic. Since we have assumed that one advertisement slot can be allocated to only
    one advertiser, the only difference in strategies is the way in which the prospective advertisers/bidders are sorted
    to find the best match for a given strategy.

    - Each function below takes a tuple t ('advertiser', 'bid') and prepares the sorting criteria.
    - Presence of '-' minus sign indicates sorting in descending order of that particular attribute.
    - Absence of '-' minus sign indicates sorting in ascending order of that particular attribute.
    - Example Criteria: -t[1], t[0] implies that the tuples are first sorted in decreasing order of t[1] and then sorts
      the previously sorted list in increasing order of t[0]. The second argument in the criteria is a tie-breaker.

    :returns:
        algorithm : function
            A lambda expression/function that will be used as a key to sort prospective advertisers.
    """

    def _greedy(t):
        """
        First sort the collection in descending order of the bid amount and use advertiser id as the tie breaker.
        """
        return -t[1], t[0]

    def _balance(t):
        """
        First sort the collection in descending order of the current budget of the advertiser and use advertiser id
        as the tie breaker.
        """
        return -current_budget[t[0]], t[0]

    def _msvv(t):
        """
        First sort the collection in descending order of the scaled current budget of the advertiser and use advertiser
        id as the tie breaker.
        """
        return -scaled_bid(initial_budget[t[0]], current_budget[t[0]], t[1]), t[0]

    if strategy == GREEDY:
        return _greedy
    if strategy == BALANCE:
        return _balance
    if strategy == MSVV:
        return _msvv


def scaled_bid(initial, current, bid):
    """
    Scale the bid using the fraction of advertisers daily budget that has already been spent.
    """
    fraction = (initial - current) / initial
    return bid * (1 - math.exp(fraction - 1))


def driver(strategy, runs):
    """
    A driver program that controls the execution and prints the average revenue generated by the algorithm and its
    competitive ratio over given number of runs.
    """
    random.seed(0)
    budget, advertisers, queries = prep_data()
    opt_revenue = sum(budget.values())
    total_revenue = 0
    for _ in range(runs):
        random.shuffle(queries)
        total_revenue += calculate_revenue(strategy, budget, budget.copy(), advertisers, queries)
    avg_revenue = total_revenue / runs
    print('Average revenue of {} algorithm across {} runs: {}'.format(strategy, runs, round(avg_revenue, 2)))
    print('Competitive ratio: {}'.format(round(avg_revenue / opt_revenue, 2)))


if __name__ == '__main__':
    GREEDY = 'greedy'
    BALANCE = 'balance'
    MSVV = 'msvv'
    strategies = [GREEDY, BALANCE, MSVV]
    error_msg = 'please provide one positional argument from <{}>, <{}>, <{}>'.format(*strategies)
    if len(sys.argv) != 2:
        print(error_msg)
        sys.exit(1)
    elif sys.argv[1] not in strategies:
        print(error_msg)
        sys.exit(1)
    else:
        driver(sys.argv[1], 100)
