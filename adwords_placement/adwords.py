import sys
import math
import random
from collections import defaultdict

import pandas as pd


def prep_data():
    """
    Prepares the data used to calculate revenue.

    :returns:
        advertisers : dict[key: 'query', value: set{('advertiser', 'bid')}])
            Adjacency list representation of query-advertiser bi-partite graph. Since we only care about the advertisers
            with respect to query terms/ad-words in this project, the graph constructed is a directed graph with all the
            edges from 'query' to 'advertisers'.
        budget : dict[key: 'advertiser', value: 'budget']
            Dictionary representing the daily budget of advertisers.
        queries : list
            List of incoming query terms/ad-words.
    """
    budget = dict()
    advertisers = defaultdict(set)
    for _, rows in pd.read_csv('bidder_dataset.csv').iterrows():
        advertisers[rows['Keyword']].add((rows['Advertiser'], rows['Bid Value']))
        if not math.isnan(rows['Budget']):
            budget[rows['Advertiser']] = rows['Budget']
    with open('queries.txt', 'r') as f:
        queries = f.read().splitlines()
    return advertisers, budget, queries


def calculate_revenue(strategy, initial_budget, current_budget, advertisers, queries):
    """
    Calculates the revenue over one pass of all the query terms/ad-words using one of the the given strategies
    from {'greedy, 'balance', 'msvv'}.

    :returns:
        revenue : int
            revenue generated by the algorithm.
    """
    # Get the algorithm to be used for ad-words allocation using given strategy.
    algorithm = get_algorithm(strategy, initial_budget, current_budget)
    revenue = 0
    for query in queries:
        # Sort the advertisers for this query term/ad-word using algorithm as the key.
        for nbr, bid in sorted(advertisers[query], key=algorithm):
            # If all bidding advertisers have exhausted their full budget, continue.
            if current_budget[nbr] >= bid:
                revenue += bid
                current_budget[nbr] -= bid
                # Since this query term/ad-word has already been allocated a slot, move on to the next ad-word.
                break
    return revenue


def get_algorithm(strategy, initial_budget, current_budget):
    """
    This function implements the core logic. Since we have assumed that one advertisement slot can be allocated to only
    one advertiser, the only difference in strategies is the way in which the prospective advertisers/bidders are sorted
    to find the best match for a given strategy.

    - Each function below takes a tuple t ('advertiser', 'bid') and prepares the sorting criteria.
    - Presence of '-' minus sign indicates sorting in descending order of that particular attribute.
    - Absence of '-' minus sign indicates sorting in ascending order of that particular attribute.
    - Example Criteria: -t[1], t[0] implies that the tuples are first sorted in decreasing order of t[1] and then sorts
      the previously sorted list in increasing order of t[0]. The second argument in the criteria is a tie-breaker.

    :returns:
        algorithm : function
            A lambda expression/function that will be used as a key to sort prospective advertisers.
    """

    def _greedy(t):
        """
        First sort the collection in descending order of the bid amount and use advertiser id as the tie breaker.
        """
        return -t[1], t[0]

    def _balance(t):
        """
        First sort the collection in descending order of the current budget of the advertiser and use advertiser id
        as the tie breaker.
        """
        return -current_budget[t[0]], t[0]

    def _msvv(t):
        """
        First sort the collection in descending order of the scaled current budget of the advertiser and use advertiser
        id as the tie breaker.
        """
        return -scaled_bid(initial_budget[t[0]], current_budget[t[0]], t[1]), t[0]

    if strategy == GREEDY:
        return _greedy
    if strategy == BALANCE:
        return _balance
    if strategy == MSVV:
        return _msvv


def scaled_bid(initial, current, bid):
    """
    Scale the bid using the fraction of advertisers daily budget that has already been spent.
    """
    fraction = (initial - current) / initial
    return bid * (1 - math.exp(fraction - 1))


def driver(strategy, runs):
    """
    A driver program that controls the execution and prints the revenue generated by the algorithm and its
    competitive ratio over a given number of runs.
    """
    advertisers, budget, queries = prep_data()
    revenue = calculate_revenue(strategy, budget, budget.copy(), advertisers, queries)
    print('The revenue generated by {} algorithm: {}'.format(strategy, round(revenue, 2)))

    # Estimate the revenue across number of runs specified by shuffling the query order.
    random.seed(0)
    opt_revenue = sum(budget.values())
    total_revenue = 0
    for _ in range(runs):
        random.shuffle(queries)
        total_revenue += calculate_revenue(strategy, budget, budget.copy(), advertisers, queries)
    avg_revenue = total_revenue / runs
    print('Competitive ratio: {}'.format(round(avg_revenue / opt_revenue, 2)))


if __name__ == '__main__':
    GREEDY = 'greedy'
    BALANCE = 'balance'
    MSVV = 'msvv'
    strategies = [GREEDY, BALANCE, MSVV]
    error_msg = 'please provide one positional argument from <{}>, <{}>, <{}>'.format(*strategies)
    if len(sys.argv) != 2:
        print(error_msg)
        sys.exit(1)
    elif sys.argv[1] not in strategies:
        print(error_msg)
        sys.exit(1)
    else:
        driver(sys.argv[1], 100)
